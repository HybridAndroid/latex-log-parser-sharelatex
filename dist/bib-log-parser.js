// Generated by CoffeeScript 1.10.0
define(function() {
  var BibLogParser, LINE_SPLITTER_REGEX, MESSAGE_LEVELS, MULTILINE_WARNING_REGEX, SINGLELINE_WARNING_REGEX, consume, consumeMultilineWarnings;
  LINE_SPLITTER_REGEX = /^\[(\d+)].*>\s(INFO|WARN|ERROR)\s-\s(.*)$/;
  MESSAGE_LEVELS = {
    "INFO": "info",
    "WARN": "warning",
    "ERROR": "error"
  };
  BibLogParser = function(text, options) {
    if (typeof text !== 'string') {
      throw new Error("BibLogParser Error: text parameter must be a string");
    }
    this.text = text.replace(/(\r\n)|\r/g, '\n');
    this.options = options || {};
    this.lines = text.split('\n');
  };
  MULTILINE_WARNING_REGEX = /^Warning--(.+)\n--line (\d+) of file (.+)$/m;
  SINGLELINE_WARNING_REGEX = /^Warning--(.+)$/m;
  consume = function(logText, regex) {
    var fileName, fullMatch, index, iterationCount, lineNumber, match, message, newEntry, re, result;
    result = [];
    re = regex;
    iterationCount = 0;
    while (match = re.exec(logText)) {
      iterationCount += 1;
      if (iterationCount >= 10000) {
        return result;
      }
      fullMatch = match[0], message = match[1], lineNumber = match[2], fileName = match[3];
      index = match.index;
      newEntry = {
        file: fileName,
        level: "warning",
        message: message,
        line: lineNumber,
        raw: fullMatch
      };
      result.push(newEntry);
      logText = (match.input.slice(0, index)) + (match.input.slice(index + fullMatch.length + 1, match.input.length));
    }
    return result;
  };
  consumeMultilineWarnings = function(logText) {
    return consume(logText, MULTILINE_WARNING_REGEX);
  };
  (function() {
    this.parseBibtex = function() {
      var multilineWarnings, result;
      result = {
        all: [],
        errors: [],
        warnings: [],
        files: [],
        typesetting: []
      };
      multilineWarnings = consumeMultilineWarnings(this.text);
      result.all = multilineWarnings;
      result.warnings = multilineWarnings;
      return result;
    };
    this.parseBiber = function() {
      var result;
      result = {
        all: [],
        errors: [],
        warnings: [],
        files: [],
        typesetting: []
      };
      this.lines.forEach(function(line) {
        var _, fileName, fullLine, lineMatch, lineNumber, match, message, messageType, newEntry, realMessage;
        match = line.match(LINE_SPLITTER_REGEX);
        if (match) {
          fullLine = match[0], lineNumber = match[1], messageType = match[2], message = match[3];
          newEntry = {
            file: null,
            level: MESSAGE_LEVELS[messageType] || "INFO",
            message: message,
            line: null,
            raw: fullLine
          };
          lineMatch = newEntry.message.match(/^BibTeX subsystem: \/.+\/(\w+\.\w+)_.+, line (\d+), (.+)$/);
          if (lineMatch && lineMatch.length === 4) {
            _ = lineMatch[0], fileName = lineMatch[1], lineNumber = lineMatch[2], realMessage = lineMatch[3];
            newEntry.file = fileName;
            newEntry.line = lineNumber;
            newEntry.message = realMessage;
          }
          result.all.push(newEntry);
          switch (newEntry.level) {
            case 'error':
              return result.errors.push(newEntry);
            case 'warning':
              return result.warnings.push(newEntry);
          }
        }
      });
      return result;
    };
    return this.parse = function() {
      var firstLine;
      firstLine = this.lines[0];
      if (firstLine.match(/^.*INFO - This is Biber.*$/)) {
        return this.parseBiber();
      } else if (firstLine.match(/^This is BibTeX, Version.+$/)) {
        return this.parseBibtex();
      } else {
        throw new Error("BibLogParser Error: cannot determine whether text is biber or bibtex output");
      }
    };
  }).call(BibLogParser.prototype);
  BibLogParser.parse = function(text, options) {
    return new BibLogParser(text, options).parse();
  };
  return BibLogParser;
});
